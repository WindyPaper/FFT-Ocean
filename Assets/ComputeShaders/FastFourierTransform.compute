#pragma enable_d3d11_debug_symbols
#pragma kernel PrecomputeTwiddleFactorsAndInputIndices
#pragma kernel HorizontalStepFFT
#pragma kernel VerticalStepFFT
#pragma kernel HorizontalStepInverseFFT
#pragma kernel VerticalStepInverseFFT
#pragma kernel Scale
#pragma kernel Permute

static const float PI = 3.1415926;

RWTexture2D<float4> PrecomputeBuffer;
Texture2D<float4> PrecomputedData;
RWTexture2D<float2> Buffer0;
RWTexture2D<float2> Buffer1;
bool PingPong;
uint Step;
uint Size;

float2 ComplexMult(float2 a, float2 b)
{
	return float2(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);
}

float2 ComplexExp(float2 a)
{
	return float2(cos(a.y), sin(a.y)) * exp(a.x);
}

[numthreads(1, 8, 1)]
void PrecomputeTwiddleFactorsAndInputIndices(uint3 id : SV_DispatchThreadID)
{
	uint b = Size >> (id.x + 1);
	float2 mult = 2 * PI * float2(0, 1) / Size;
	uint i = (2 * b * (id.y / b) + id.y % b) % Size;
	float2 twiddle = ComplexExp(-mult * ((id.y / b) * b));
	PrecomputeBuffer[id.xy] = float4(twiddle.x, twiddle.y, i, i + b);
	PrecomputeBuffer[uint2(id.x, id.y + Size / 2)] = float4(-twiddle.x, -twiddle.y, i, i + b);
}

[numthreads(8, 8, 1)]
void HorizontalStepFFT (uint3 id : SV_DispatchThreadID)
{
	float4 data = PrecomputedData[uint2(Step, id.x)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(data.rg, Buffer0[uint2(inputsIndices.y, id.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(data.rg, Buffer1[uint2(inputsIndices.y, id.y)]);
	}
}

[numthreads(8, 8, 1)]
void VerticalStepFFT(uint3 id : SV_DispatchThreadID)
{
	float4 data = PrecomputedData[uint2(Step, id.y)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(data.rg, Buffer0[uint2(id.x, inputsIndices.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(data.rg, Buffer1[uint2(id.x, inputsIndices.y)]);
	}
}

groupshared float2 ButterFlyCacheData[256];

void fft(inout float2 h[2], uint thread_id, uint N)
{
	//butterfly	
	bool flag = false;
	float scale = PI * 0.5f; // Pi
							 //stage 0 //cos0 = 1, sin0 = 0
	{
		float2 dht = h[1];

		h[1] = h[0] - dht;
		h[0] = h[0] + dht;
		
		flag = thread_id & 1;
		if (flag)
		{
			ButterFlyCacheData[thread_id] = h[0];
		}
		else
		{
			ButterFlyCacheData[thread_id] = h[1];
		}

		GroupMemoryBarrier();
	}

	uint stage_id = 1;
	for (uint stage = 2; stage < N; stage <<= 1, scale *= 0.5)
	{
		uint i = thread_id ^ (stage - 1); //pair index
		uint j = thread_id & (stage - 1); //curr n index

		if (flag)
		{
			h[0] = ButterFlyCacheData[i];
		}
		else
		{
			h[1] = ButterFlyCacheData[i];
		}

		/*float e_sin, e_cos;
		sincos(j * scale, e_sin, e_cos);
		float2 omega_j = float2(e_cos, e_sin);*/

		uint b = N >> (stage_id + 1);
		stage_id++;
		float2 mult = 2 * PI * float2(0, 1) / N;		
		float2 twiddle = ComplexExp(-mult * ((j / b) * b));
		float e_cos = twiddle.x;
		float e_sin = twiddle.y;
		float2 omega_j = float2(e_cos, e_sin);		

		float2 dht = ComplexMult(omega_j, h[1]);

		h[1] = h[0] - dht;
		h[0] = h[0] + dht;

		flag = thread_id & stage;

		if (flag)
		{
			ButterFlyCacheData[i] = h[0];
		}
		else
		{
			ButterFlyCacheData[i] = h[1];
		}

		GroupMemoryBarrierWithGroupSync();
	}
}

void fft2(inout float2 h[2], uint x, uint N)
{
	//butterfly	
	bool flag = false;
	float scale = PI * 0.5f; // Pi
							 //stage 0 //cos0 = 1, sin0 = 0
	{
		float2 dht = h[1];

		h[1] = h[0] - dht;
		h[0] = h[0] + dht;

		flag = x & 1;
		if (flag)
		{
			ButterFlyCacheData[x] = h[0];
		}
		else
		{
			ButterFlyCacheData[x] = h[1];
		}

		GroupMemoryBarrierWithGroupSync();
	}

	uint stage_id = 1;
	for (uint stage = 2; stage < N; stage <<= 1, scale *= 0.5)
	{
		//float4 data = PrecomputedData[uint2(stage_id, x)];
		uint i = x ^ (stage - 1); //pair index
		uint j = x & (stage - 1); //curr n index

		if (flag)
		{
			h[0] = ButterFlyCacheData[i];
		}
		else
		{
			h[1] = ButterFlyCacheData[i];
		}

		float e_sin, e_cos;
		sincos(j * scale, e_sin, e_cos);
		float2 omega_j = float2(e_cos, e_sin);

		//uint b = N >> (stage_id + 1);
		//stage_id++;
		//float2 mult = 2 * PI * float2(0, 1) / N;
		//float2 twiddle = ComplexExp(-mult * ((j / b) * b));
		//float e_cos = twiddle.x;
		//float e_sin = twiddle.y;
		//float2 omega_j = float2(e_cos, e_sin);

		//float2 omega_j = float2(data.x, data.y);

		float2 dht = ComplexMult(omega_j, h[1]);

		h[1] = h[0] - dht;
		h[0] = h[0] + dht;

		flag = x & stage;

		if (flag)
		{
			ButterFlyCacheData[i] = h[0];
		}
		else
		{
			ButterFlyCacheData[i] = h[1];
		}

		GroupMemoryBarrierWithGroupSync();
	}
}

groupshared float2 FullButterFlyCacheData[256];

[numthreads(128, 1, 1)]
void HorizontalStepInverseFFT(uint3 id : SV_DispatchThreadID)
{
	//float4 data = PrecomputedData[uint2(Step, id.x)];
	//uint2 inputsIndices = (uint2)data.ba;
	/*if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(float2(data.r, -data.g), Buffer0[uint2(inputsIndices.y, id.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(float2(data.r, -data.g), Buffer1[uint2(inputsIndices.y, id.y)]);
	}*/

	const uint N = Size;
	const uint Half_N = N / 2;
	const uint BitNum = log2(N);

	uint Column = id.x * 2;
	uint Row = id.y;
	uint ReverseColumnIdx = reversebits(Column) >> (32 - BitNum);
	uint PairColumnIdx = ReverseColumnIdx + Half_N;

	uint2 Idx0 = uint2(ReverseColumnIdx, Row);
	uint2 Idx1 = uint2(PairColumnIdx, Row);

	float2 h[2];
	h[0] = Buffer0[Idx0];
	h[1] = Buffer0[Idx1];

	//loop
	fft2(h, id.x, N);
	

	uint2 BufferIdx = id.xy;
	Buffer1[BufferIdx] = h[0];
	Buffer1[BufferIdx + uint2(Half_N, 0)] = h[1];

	//const uint N = 256;
	//const uint Half_N = N / 2;
	//float4 data = PrecomputedData[uint2(0, id.x)];
	//uint2 inputsIndices = (uint2)data.ba;	
	//float2 h = Buffer0[uint2(inputsIndices.x, id.y)];
	//float2 hp = Buffer0[uint2(inputsIndices.y, id.y)];
	//uint i = id.x;
	//FullButterFlyCacheData[i] = h;
	//FullButterFlyCacheData[i + Half_N] = hp;
	//GroupMemoryBarrierWithGroupSync();

	//uint logSize = (uint)log2(N);
	//for (uint stage = 0; stage < logSize; stage++)
	//{
	//	bool flag = stage & 1;

	//	float4 data = PrecomputedData[uint2(stage, id.x)];
	//	uint2 inputsIndices = (uint2)data.ba;

	//	//test
	//	if (flag)
	//	{
	//		h = FullButterFlyCacheData[inputsIndices.x];
	//	}
	//	else
	//	{
	//		hp = FullButterFlyCacheData[inputsIndices.x];
	//	}

	//	float2 t = ComplexMult(float2(data.r, -data.g), FullButterFlyCacheData[inputsIndices.y]);		

	//	float2 hp = FullButterFlyCacheData[inputsIndices.x] - t;
	//	float2 h = FullButterFlyCacheData[inputsIndices.x] + t;

	//	GroupMemoryBarrierWithGroupSync();

	//	FullButterFlyCacheData[i] = h;
	//	FullButterFlyCacheData[i + Half_N] = hp;

	//	GroupMemoryBarrierWithGroupSync();
	//}
	////{
	//	/*FullButterFlyCacheData[id.x] = Buffer0[uint2(inputsIndices.x, id.y)]
	//		+ ComplexMult(float2(data.r, -data.g), Buffer0[uint2(inputsIndices.y, id.y)]);*/

	//	//test
	//	//float2 h[2];
	//	//h[0] = Buffer0[uint2(inputsIndices.x, id.y)];
	//	//h[1] = Buffer0[uint2(inputsIndices.y, id.y)];
	//	////float2 h[2];
	//	//float2 du = h[1];// ComplexMult(float2(data.r, -data.g), h[1]);
	//	//h[1] = h[0] - du;
	//	//h[0] = h[0] + du;
	//	//uint threadIdx = id.x;
	//	//bool flag = threadIdx & 1;
	//	//uint i = id.x;
	//	//if (flag)
	//	//{
	//	//	FullButterFlyCacheData[i] = h[0];
	//	//}
	//	//else {
	//	//	FullButterFlyCacheData[i] = h[1];
	//	//}
	//	////end test

	//	//GroupMemoryBarrierWithGroupSync();

	//	//uint logSize = 8;// (uint)log2(N);

	//	////uint stage_no = 1;
	//	//[unroll(8)]
	//	//for (uint stage = 1; stage < logSize; stage++)
	//	//{
	//	//	float4 data = PrecomputedData[uint2(stage, id.x)];
	//	//	uint2 inputsIndices = (uint2)data.ba;
	//	//	//stage_no++;

	//	//	//GroupMemoryBarrierWithGroupSync();

	//	//	FullButterFlyCacheData[id.x] = FullButterFlyCacheData[inputsIndices.x]
	//	//		+ ComplexMult(float2(data.r, -data.g), FullButterFlyCacheData[inputsIndices.y]);

	//	//	GroupMemoryBarrierWithGroupSync();
	//	//}		

	//	//test	
	////	float scale = 3.14159265359f * 0.5f; // Pi
	////	uint stage_no = 1;
	////	for (uint stride = 2; stride <= N; stride <<= 1, scale *= 0.5f)
	////	{			
	////		uint i = threadIdx ^ (stride - 1); //pair
	////		uint j = threadIdx & (stride - 1); //curr

	////		float4 data = PrecomputedData[uint2(stage_no, N / stride * j)];
	////		++stage_no;

	////		if (flag)
	////		{
	////			h[0] = FullButterFlyCacheData[i];
	////		}
	////		else {
	////			h[1] = FullButterFlyCacheData[i];
	////		}
	////		
	////		float sin, cos;
	////		sincos(j * scale, sin, cos);

	////		//float2 du = ComplexMult(float2(data.r, -data.g), h[1]);
	////		float2 du = ComplexMult(float2(cos, sin), h[1]);
	////		h[1] = h[0] - du;
	////		h[0] = h[0] + du;

	////		flag = threadIdx & stride;
	////		if (flag)
	////		{
	////			FullButterFlyCacheData[i] = h[0];
	////		}
	////		else {
	////			FullButterFlyCacheData[i] = h[1];
	////		}

	////		GroupMemoryBarrierWithGroupSync();
	////	}
	//////}
	////GroupMemoryBarrierWithGroupSync();

	//Buffer1[id.xy] = FullButterFlyCacheData[id.x];
	//Buffer1[id.xy+uint2(Half_N, 0)] = FullButterFlyCacheData[i + Half_N];
	////Buffer1[id.xy] = float2(1.0, 0.0);

	//GroupMemoryBarrierWithGroupSync();
}

[numthreads(256, 1, 1)]
void VerticalStepInverseFFT(uint3 id : SV_DispatchThreadID)
{
	/*float4 data = PrecomputedData[uint2(Step, id.y)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(float2(data.r, -data.g), Buffer0[uint2(id.x, inputsIndices.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(float2(data.r, -data.g), Buffer1[uint2(id.x, inputsIndices.y)]);
	}*/

	//const uint N = 256;
	//const uint Half_N = N / 2;

	//uint Row = id.x * 2;
	//uint Column = id.y;
	//uint ReverseRowIdx = reversebits(Row) >> (32 - 8);
	//uint PairRowIdx = Half_N - ReverseRowIdx;

	//uint2 Idx0 = uint2(Column, ReverseRowIdx);
	//uint2 Idx1 = uint2(Column, PairRowIdx);

	//float2 h[2];
	//h[0] = Buffer1[Idx0];
	//h[1] = Buffer1[Idx1];
	//h[1].y *= -1;

	////loop
	//uint thread_id = id.x;

	//fft2(h, thread_id, N);

	//uint2 BufferIdx = uint2(Column, id.x);
	//Buffer0[BufferIdx] = h[0];
	//Buffer0[BufferIdx + uint2(0, Half_N)] = h[1];

	const uint N = 256;
	float4 data = PrecomputedData[uint2(0, id.x)];
	float2 CacheH;
	uint2 inputsIndices = (uint2)data.ba;
	//{
		FullButterFlyCacheData[id.x] = Buffer1[uint2(id.y, inputsIndices.x)]
			+ ComplexMult(float2(data.r, -data.g), Buffer1[uint2(id.y, inputsIndices.y)]);

		GroupMemoryBarrierWithGroupSync();

		//uint stage_no = 1;
		uint logSize = 8;// (uint)log2(N);
		[unroll(8)]
		for (uint stage = 1; stage < logSize; stage++)
		{
			float4 data = PrecomputedData[uint2(stage, id.x)];
			uint2 inputsIndices = (uint2)data.ba;
			//stage_no++;

			//GroupMemoryBarrierWithGroupSync();

			CacheH = FullButterFlyCacheData[inputsIndices.x]
				+ ComplexMult(float2(data.r, -data.g), FullButterFlyCacheData[inputsIndices.y]);

			GroupMemoryBarrierWithGroupSync();

			FullButterFlyCacheData[id.x] = CacheH;

			GroupMemoryBarrierWithGroupSync();
		}

		//AllMemoryBarrierWithGroupSync();
	//}

	GroupMemoryBarrierWithGroupSync();

	Buffer0[id.yx] = FullButterFlyCacheData[id.x];

	GroupMemoryBarrierWithGroupSync();
}

[numthreads(8, 8, 1)]
void Scale(uint3 id : SV_DispatchThreadID)
{
	Buffer0[id.xy] = Buffer0[id.xy] / Size / Size;
}

[numthreads(8, 8, 1)]
void Permute(uint3 id : SV_DispatchThreadID)
{
	Buffer0[id.xy] = Buffer0[id.xy] * (1.0 - 2.0 * ((id.x + id.y) % 2));
}
