#pragma enable_d3d11_debug_symbols
#pragma kernel PrecomputeTwiddleFactorsAndInputIndices
#pragma kernel HorizontalStepFFT
#pragma kernel VerticalStepFFT
#pragma kernel HorizontalStepInverseFFT
#pragma kernel VerticalStepInverseFFT
#pragma kernel Scale
#pragma kernel Permute

static const float PI = 3.1415926;

RWTexture2D<float4> PrecomputeBuffer;
Texture2D<float4> PrecomputedData;
RWTexture2D<float2> Buffer0;
RWTexture2D<float2> Buffer1;
bool PingPong;
uint Step;
uint Size;

float2 ComplexMult(float2 a, float2 b)
{
	return float2(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);
}

float2 ComplexExp(float2 a)
{
	return float2(cos(a.y), sin(a.y)) * exp(a.x);
}

[numthreads(1, 8, 1)]
void PrecomputeTwiddleFactorsAndInputIndices(uint3 id : SV_DispatchThreadID)
{
	uint b = Size >> (id.x + 1);
	float2 mult = 2 * PI * float2(0, 1) / Size;
	uint i = (2 * b * (id.y / b) + id.y % b) % Size;
	float2 twiddle = ComplexExp(-mult * ((id.y / b) * b));
	PrecomputeBuffer[id.xy] = float4(twiddle.x, twiddle.y, i, i + b);
	PrecomputeBuffer[uint2(id.x, id.y + Size / 2)] = float4(-twiddle.x, -twiddle.y, i, i + b);
}

[numthreads(8, 8, 1)]
void HorizontalStepFFT (uint3 id : SV_DispatchThreadID)
{
	float4 data = PrecomputedData[uint2(Step, id.x)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(data.rg, Buffer0[uint2(inputsIndices.y, id.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(inputsIndices.x, id.y)]
			+ ComplexMult(data.rg, Buffer1[uint2(inputsIndices.y, id.y)]);
	}
}

[numthreads(8, 8, 1)]
void VerticalStepFFT(uint3 id : SV_DispatchThreadID)
{
	float4 data = PrecomputedData[uint2(Step, id.y)];
	uint2 inputsIndices = (uint2)data.ba;
	if (PingPong)
	{
		Buffer1[id.xy] = Buffer0[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(data.rg, Buffer0[uint2(id.x, inputsIndices.y)]);
	}
	else
	{
		Buffer0[id.xy] = Buffer1[uint2(id.x, inputsIndices.x)]
			+ ComplexMult(data.rg, Buffer1[uint2(id.x, inputsIndices.y)]);
	}
}

groupshared float2 ButterFlyCacheData[256];

void fft(inout float2 h[2], uint thread_id, uint N)
{
	//butterfly	
	bool flag = false;
	float scale = PI * 0.5f; // Pi
							 //stage 0 //cos0 = 1, sin0 = 0
	{
		float2 dht = h[1];

		h[1] = h[0] - dht;
		h[0] = h[0] + dht;
		
		flag = thread_id & 1;
		if (flag)
		{
			ButterFlyCacheData[thread_id] = h[0];
		}
		else
		{
			ButterFlyCacheData[thread_id] = h[1];
		}

		GroupMemoryBarrier();
	}

	uint stage_id = 1;
	for (uint stage = 2; stage < N; stage <<= 1, scale *= 0.5)
	{
		uint i = thread_id ^ (stage - 1); //pair index
		uint j = thread_id & (stage - 1); //curr n index

		if (flag)
		{
			h[0] = ButterFlyCacheData[i];
		}
		else
		{
			h[1] = ButterFlyCacheData[i];
		}

		/*float e_sin, e_cos;
		sincos(j * scale, e_sin, e_cos);
		float2 omega_j = float2(e_cos, e_sin);*/

		uint b = N >> (stage_id + 1);
		stage_id++;
		float2 mult = 2 * PI * float2(0, 1) / N;		
		float2 twiddle = ComplexExp(-mult * ((j / b) * b));
		float e_cos = twiddle.x;
		float e_sin = twiddle.y;
		float2 omega_j = float2(e_cos, e_sin);		

		float2 dht = ComplexMult(omega_j, h[1]);

		h[1] = h[0] - dht;
		h[0] = h[0] + dht;

		flag = thread_id & stage;

		if (flag)
		{
			ButterFlyCacheData[i] = h[0];
		}
		else
		{
			ButterFlyCacheData[i] = h[1];
		}

		GroupMemoryBarrierWithGroupSync();
	}
}

void fft2(inout float2 h[2], uint x, uint N)
{
	//butterfly	
	bool flag = false;
	float scale = PI * 0.5f; // Pi
							 //stage 0 //cos0 = 1, sin0 = 0
	{
		float2 dht = h[1];

		h[1] = h[0] - dht;
		h[0] = h[0] + dht;

		flag = x & 1;
		if (flag)
		{
			ButterFlyCacheData[x] = h[0];
		}
		else
		{
			ButterFlyCacheData[x] = h[1];
		}

		GroupMemoryBarrierWithGroupSync();
	}

	uint stage_id = 1;
	for (uint stage = 2; stage < N; stage <<= 1, scale *= 0.5)
	{
		//float4 data = PrecomputedData[uint2(stage_id, x)];
		uint i = x ^ (stage - 1); //pair index
		uint j = x & (stage - 1); //curr n index

		if (flag)
		{
			h[0] = ButterFlyCacheData[i];
		}
		else
		{
			h[1] = ButterFlyCacheData[i];
		}

		float e_sin, e_cos;
		sincos(j * scale, e_sin, e_cos);
		float2 omega_j = float2(e_cos, e_sin);

		//uint b = N >> (stage_id + 1);
		//stage_id++;
		//float2 mult = 2 * PI * float2(0, 1) / N;
		//float2 twiddle = ComplexExp(-mult * ((j / b) * b));
		//float e_cos = twiddle.x;
		//float e_sin = twiddle.y;
		//float2 omega_j = float2(e_cos, e_sin);

		//float2 omega_j = float2(data.x, data.y);

		float2 dht = ComplexMult(omega_j, h[1]);

		h[1] = h[0] - dht;
		h[0] = h[0] + dht;

		flag = x & stage;

		if (flag)
		{
			ButterFlyCacheData[i] = h[0];
		}
		else
		{
			ButterFlyCacheData[i] = h[1];
		}

		GroupMemoryBarrierWithGroupSync();
	}
}

groupshared float2 FullButterFlyCacheData[256];

[numthreads(128, 1, 1)]
void HorizontalStepInverseFFT(uint3 id : SV_DispatchThreadID)
{
	const uint N = Size;
	const uint Half_N = N / 2;
	const uint BitNum = log2(N);

	uint Column = id.x * 2;
	uint Row = id.y;
	uint ReverseColumnIdx = reversebits(Column) >> (32 - BitNum);
	uint PairColumnIdx = ReverseColumnIdx + Half_N;

	uint2 Idx0 = uint2(ReverseColumnIdx, Row);
	uint2 Idx1 = uint2(PairColumnIdx, Row);

	float2 h[2];
	h[0] = Buffer0[Idx0];
	h[1] = Buffer0[Idx1];

	//loop
	fft2(h, id.x, N);
	

	uint2 BufferIdx = id.xy;
	Buffer1[BufferIdx] = h[0];
	Buffer1[BufferIdx + uint2(Half_N, 0)] = h[1];	
}

[numthreads(128, 1, 1)]
void VerticalStepInverseFFT(uint3 id : SV_DispatchThreadID)
{
	const uint N = Size;
	const uint Half_N = N / 2;
	const uint BitNum = log2(N);

	uint Row = id.x * 2;
	uint Column = id.y;
	uint ReverseRowIdx = reversebits(Row) >> (32 - BitNum);
	//uint PairRowIdx = Half_N - ReverseRowIdx;
	uint PairRowIdx = ReverseRowIdx + Half_N;

	uint2 Idx0 = uint2(Column, ReverseRowIdx);
	uint2 Idx1 = uint2(Column, PairRowIdx);

	float2 h[2];
	h[0] = Buffer1[Idx0];
	h[1] = Buffer1[Idx1];

	//test
	//uint2 TestPartIdx = uint2(Column, N - PairRowIdx);
	//h[1] = Buffer1[TestPartIdx];
	//h[1].y = -h[1].y;

	//loop
	uint thread_id = id.x;

	fft2(h, thread_id, N);

	uint2 BufferIdx = uint2(Column, id.x);
	uint2 PairBufferIdx = BufferIdx + uint2(0, Half_N);

	float PermuteIdx = (1.0 - 2.0 * ((BufferIdx.x + BufferIdx.y) % 2));
	float PermutePair = (1.0 - 2.0 * ((PairBufferIdx.x + PairBufferIdx.y) % 2));
	Buffer0[BufferIdx] = h[0] * PermuteIdx;
	Buffer0[BufferIdx + uint2(0, Half_N)] = h[1] * PermutePair;
}

[numthreads(8, 8, 1)]
void Scale(uint3 id : SV_DispatchThreadID)
{
	Buffer0[id.xy] = Buffer0[id.xy] / Size / Size;
}

[numthreads(8, 8, 1)]
void Permute(uint3 id : SV_DispatchThreadID)
{
	Buffer0[id.xy] = Buffer0[id.xy] * (1.0 - 2.0 * ((id.x + id.y) % 2));
}
